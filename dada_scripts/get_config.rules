import os
import shutil
import gzip
import yaml
#import bz2
from copy import deepcopy
import subprocess
import pandas as pd
from snakemake.utils import validate

def dict_merge(a, b):
    """
    Deep merge 2 dicts together
    """
    if not isinstance(b, dict):
        return b
    result = deepcopy(a)
    for k, v in b.items():
        if k in result and isinstance(result[k], dict):
            result[k] = dict_merge(result[k], v)
        else:
            result[k] = deepcopy(v)
    return result


# default configuration file
#configfile: "config.default.yaml"
# validate(config,schema="schemas/config.schema.yaml")

# default executable for snakemake
shell.executable("bash")

# custom configuration file
CUSTOM_CONFIG_PATH = os.environ.get("CONFIGFILE")
print("read configuration from "+CUSTOM_CONFIG_PATH)

# merge 2 configurations files together
if os.path.exists(CUSTOM_CONFIG_PATH):
    with open(CUSTOM_CONFIG_PATH, 'r') as rhandle:
        data = yaml.load(rhandle)
        config = dict_merge(config, data)

#validate(config,schema="schemas/config.schema.yaml")

samples = pd.read_table(os.path.expandvars(config['sample_table']))
if 'run' in samples.columns:
    samples['run'] = samples['run'].astype(str)
    for r in samples['run']:
        if not re.match(r"[0-9a-zA-Z]",r):
            raise Exception('please start run names with a letter or number')
else:
    samples['run'] = ["run1"] * samples.shape[0]
    print("adding column with run info")
if samples[['library','run']].duplicated().any():
    raise Exception('names in library should be unique within runs.')
samples = samples.set_index(["library","run"],drop=False)
samples.index = samples.index.set_levels([i.astype(str) for i in samples.index.levels]) 
samples['library'] = samples['library'].astype(str)
for lib in samples['library']:
    if not re.match(r"[0-9a-zA-Z]",lib):
        raise Exception('please start library names with a letter or number')
if 'sample' not in samples.columns:
    samples['sample'] = samples['library']
    print("adding column with sample names based on library names")
else:
    samples['sample'] = samples['sample'].astype(str)
    for r in samples['run'].unique():
        tmpsr=samples[samples['run']==r]
        for i in range(tmpsr.shape[0]):
            csam = tmpsr['sample'][i]
            if not re.match(r"[0-9a-zA-Z]",csam):
                raise Exception('please start sample names with a letter or number')
            for j in range(tmpsr.shape[0]):
                clib = tmpsr['library'][j]
                if csam==clib and i==j:
                    csl = tmpsr.loc[tmpsr["sample"]==csam,"library"]
                    if len(csl) > 1:
                        raise Exception('names in library should differ from names of samples that have multiple libraries in the same run.')
                elif csam==clib:
                    raise Exception('names in library should differ from unrelated sample names.')    
print(samples)

#validate(samples, schema="schemas/sample.schema.yaml")

# get parameters from the command line
OUTPUTDIR = os.environ.get("OUTPUTDIR", os.path.expandvars(config['outputdir']))

PRELIM_STEPS = ''
if config['do_primers']:
    PRELIM_STEPS += "primers "
if config['do_dada']:
    PRELIM_STEPS += "dada "
    if config['do_taxonomy']:
        PRELIM_STEPS += "taxonomy "
    if config['do_postprocessing']:
        PRELIM_STEPS += "postprocessing "

STEPS = os.environ.get("STEPS", PRELIM_STEPS).split()

# temporary directory will be stored inside the OUTPUTDIR directory
# unless an absolute path is set
TMPDIR = os.path.expandvars(os.environ.get("TMPDIR", config['tmp_dir']))
if not os.path.isabs(TMPDIR):
    TMPDIR = os.path.join(OUTPUTDIR, TMPDIR)
if not os.path.exists(TMPDIR):
    os.makedirs(TMPDIR)


